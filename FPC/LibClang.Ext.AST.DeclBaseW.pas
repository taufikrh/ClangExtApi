unit LibClang.Ext.AST.DeclBaseW;

{$mode ObjFPC}{$H+}
{$modeswitch advancedrecords}
{$modeswitch typehelpers}

interface

uses
  LibClang.Index,
  LibClang.CXString,
  LibClang.Ext.Basic.LangOptionsH,
  LibClang.Ext.AST.ASTContextH,
  LibClang.Ext.Basic.SpecifiersH,
  LibClang.Ext.AST.AttrH,  
  LibClang.Ext.AST.StmtH,
  LibClang.Ext.ModuleU,
  LibClang.Extended,
  LibClang.Ext.AST.DeclTemplateH,
  LibClang.Ext.AST.TypeH,
  LibClang.Ext.AST.DeclBaseH,  
  LibClang.Ext.AST.DeclH,
  LibClang.Ext.AST.DeclBaseU,
  LibClang.Ext.AST.DeclCXXH;

type

  { TDeclW }

  TDeclW = object
    D: Decl;
  public
    class function Create(const aDecl: Decl): TDeclW; static;
    function getDeclKind(const aDecl: Decl): CX_DeclKind; static;
    function IsNull: Boolean; inline;
    class function castFromDeclContext(const DC: DeclContext; out aDecl: TDeclW): Boolean;
  public
    function getUSR(TU: CXTranslationUnit): string;
    function getSourceRange: CXSourceRange;
    function getBeginLoc: CXSourceLocation;
    function getEndLoc: CXSourceLocation;
    function getLocation: CXSourceLocation;
    function getKind: CX_DeclKind;
    function getDeclKindName: string;
    function getNextDeclInContext: string;
    function getDeclContext: DeclContext;
    function getNonClosureContext(out aDecl: TDeclW): Boolean;
    function getTranslationUnitDecl: TranslationUnitDecl;
    function isInAnonymousNamespace: Boolean;
    function isInStdNamespace: Boolean;
    function getASTContext: ASTContext;
    function getLangOpts: LangOptions;
    function getAccess: AccessSpecifier;
    function getAccessUnsafe: AccessSpecifier;
    function hasAttrs: Boolean;
    function getAttr(i: Cardinal): Attr;
    function getAttrCount: Cardinal;
    function getMaxAlignment: Cardinal;
    function isInvalidDecl: Boolean;
    // isImplicit - Indicates whether the declaration was implicitly
    // generated by the implementation. If false, this declaration
    // was written explicitly in the source code.
    function isImplicit: Boolean;
    function isUsed(CheckUsedAttr: Boolean = True): Boolean;
    function isReferenced: Boolean;
    function isThisDeclarationReferenced: Boolean;
    function isTopLevelDeclInObjCContainer: Boolean;
    function getExternalSourceSymbolAttr: ExternalSourceSymbolAttr;
    function isModulePrivate: Boolean;
    function isInExportDeclContext: Boolean;
    function hasDefiningAttr: Boolean;
    function getDefiningAttr: Attr;
    function isWeakImported: Attr;
    function isFromASTFile: Boolean;
    function getGlobalID: Cardinal;
    function getOwningModuleID: Cardinal;
    function getImportedOwningModule: Module;
    function getLocalOwningModule: Module;
    function hasOwningModule: Boolean;
    function getOwningModule: Module;
    function getOwningModuleForLinkage(IgnoreLinkage: Boolean = False): Module;
    function isUnconditionallyVisible: Boolean;
    function getModuleOwnershipKind: CX_Decl_ModuleOwnershipKind;
    function getIdentifierNamespace: Cardinal;
    function isInIdentifierNamespace(NS: Cardinal): Boolean;
    class function getIdentifierNamespaceForKind(DK: CX_DeclKind): Cardinal;
    function hasTagIdentifierNamespace: Boolean;   
    class function isTagIdentifierNamespace(NS: Cardinal): Boolean;
    function getLexicalDeclContext: DeclContext;
    function isOutOfLine: Boolean;
    function isTemplated: Boolean;
    function getTemplateDepth: Cardinal;
    function isDefinedOutsideFunctionOrMethod: Boolean;
    function isInLocalScopeForInstantiation: Boolean;
    function getParentFunctionOrMethod: DeclContext;
    function getCanonicalDecl: TDeclW;
    function isCanonicalDecl: Boolean;
    function getNumRedecls: Cardinal;
    function getRedecls(i: Cardinal): TDeclW;
    function getPreviousDecl: TDeclW;
    function isFirstDecl: Boolean;
    function getMostRecentDecl: TDeclW;
    function getBody: Stmt;
    function hasBody: Boolean;
    function getBodyRBrace: CXSourceLocation;
    function isTemplateParameter: Boolean;
    function isTemplateParameterPack: Boolean;
    function isParameterPack: Boolean;
    function isTemplateDecl: Boolean;
    function isFunctionOrFunctionTemplate: Boolean;
    function getDescribedTemplate: TemplateDecl;
    function getDescribedTemplateParams: TemplateParameterList;
    function getAsFunction: FunctionDecl;
    function isLocalExternDecl: Boolean;
    function getFriendObjectKind: CX_Decl_FriendObjectKind;
    function castToDeclContext: DeclContext;
    function getID: Int64;
    function getFunctionType(BlocksToo: Boolean = True): FunctionType;
    function declaresSameEntity(other: TDeclW): Boolean;
    procedure dumpToFile(const fileName: string; Deserialize: Boolean = False; OutputFormat: ASTDumpOutputFormat = ADOF_Default);
    function dumpToString(Deserialize: Boolean = False; OutputFormat: ASTDumpOutputFormat = ADOF_Default): string;
  end;
  PDeclW = ^TDeclW;

  { TDeclContextW }

  TDeclContextW = object
    Ctx: DeclContext; 
  public
    class function Create(const aCtx: DeclContext): TDeclContextW; static;
    class function classof(decl: TDeclW): Boolean; static;
  public
    function getDeclKind: CX_DeclKind;
    function getDeclKindName: string;
    function getParent: TDeclContextW;
    function getLexicalParent: TDeclContextW;
    function getLookupParent: TDeclContextW;
    function getParentASTContext: ASTContext;
    function isClosure: Boolean;
    function getInnermostBlockDecl: BlockDecl;
    function isObjCContainer: Boolean;
    function isFunctionOrMethod: Boolean;
    function isLookupContext: Boolean;
    function isFileContext: Boolean;
    function isTranslationUnit: Boolean;
    function isRecord: Boolean;
    function isNamespace: Boolean;
    function isStdNamespace: Boolean;
    function isInlineNamespace: Boolean;
    function isDependentContext: Boolean;
    function isTransparentContext: Boolean;
    function isExternCContext: Boolean;
    function getExternCContext: LinkageSpecDecl;
    function isExternCXXContext: Boolean;
    function Equals(DC: TDeclContextW): Boolean;
    function Encloses(DC: TDeclContextW): Boolean;
    function getNonClosureAncestor: Decl;
    function getNonTransparentContext: TDeclContextW;
    function getPrimaryContext: TDeclContextW;
    function getRedeclContext: TDeclContextW;
    function getEnclosingNamespaceContext: TDeclContextW;
    function getOuterLexicalRecordContext: RecordDecl;
    function InEnclosingNamespaceSetOf(NS: TDeclContextW): Boolean;
    function getNumDecls: Cardinal;
    function getDecls(i: Cardinal): TDeclW;
    function decls_empty: Boolean;
    function containsDecl(decl_: TDeclW): Boolean;
  end;
          
  { DeclHelper }

  DeclHelper = type helper for Decl
  public
    function Wrap(out D: TDeclW): Boolean; inline;
  end;

  { DeclContextHelper }

  DeclContextHelper = type helper for DeclContext
  public
    function Wrap(out D: TDeclContextW): Boolean; inline;
  end;

implementation

uses
  SysUtils;

{ DeclHelper }

function DeclHelper.Wrap(out D: TDeclW): Boolean;
begin
  D := TDeclW.Create(Self);
  Result := Assigned(D.D);
end;
  
{ DeclContextHelper }

function DeclContextHelper.Wrap(out D: TDeclContextW): Boolean;
begin
  D := TDeclContextW.Create(Self);
  Result := Self <> nil;
end;

{$region 'TDeclW'}

class function TDeclW.Create(const aDecl: Decl): TDeclW;
begin
  Result := Default(TDeclW);
  Result.D := aDecl;
end;

function TDeclW.getDeclKind(const aDecl: Decl): CX_DeclKind;
begin
  Result := clangExt_Decl_getKind(aDecl);
end;

function TDeclW.IsNull: Boolean;
begin
  Result := not Assigned(D);
end;

class function TDeclW.castFromDeclContext(const DC: DeclContext; out
  aDecl: TDeclW): Boolean;
begin
  aDecl := TDeclW.Create(clangExt_Decl_castFromDeclContext(DC));
  Result := Assigned(aDecl.D);
end;

function TDeclW.getUSR(TU: CXTranslationUnit): string;
begin
  Result := clangExt_getDeclUSR(D, TU).ToString;
end;

function TDeclW.getSourceRange: CXSourceRange;
begin
  Result := clangExt_Decl_getSourceRange(D);
end;

function TDeclW.getBeginLoc: CXSourceLocation;
begin
  Result := clangExt_Decl_getBeginLoc(D);
end;

function TDeclW.getEndLoc: CXSourceLocation;
begin
  Result := clangExt_Decl_getEndLoc(D);
end;

function TDeclW.getLocation: CXSourceLocation;
begin
  Result := clangExt_Decl_getLocation(D);
end;

function TDeclW.getKind: CX_DeclKind;
begin
  Result := clangExt_Decl_getKind(D);
end;

function TDeclW.getDeclKindName: string;
var
  p: PChar;
begin
  p := clangExt_Decl_getDeclKindName(D);
  if Assigned(p) then
    Result := Strpas(p)
  else
    Result := EmptyStr;
end;

function TDeclW.getNextDeclInContext: string; 
var
  p: PChar;
begin
  p := clangExt_Decl_getNextDeclInContext(D);
  if Assigned(p) then
    Result := Strpas(p)
  else
    Result := EmptyStr;
end;

function TDeclW.getDeclContext: DeclContext;
begin
  Result := clangExt_Decl_getDeclContext(D);
end;

function TDeclW.getNonClosureContext(out aDecl: TDeclW): Boolean;
begin
  Result := clangExt_Decl_getNonClosureContext(D).Wrap(aDecl);
end;

function TDeclW.getTranslationUnitDecl: TranslationUnitDecl;
begin
  Result := clangExt_Decl_getTranslationUnitDecl(D);
end;

function TDeclW.isInAnonymousNamespace: Boolean;
begin
  Result := clangExt_Decl_isInAnonymousNamespace(D);
end;

function TDeclW.isInStdNamespace: Boolean;
begin
  Result := clangExt_Decl_isInStdNamespace(D);
end;

function TDeclW.getASTContext: ASTContext;
begin
  Result := clangExt_Decl_getASTContext(D);
end;

function TDeclW.getLangOpts: LangOptions;
begin
  Result := clangExt_Decl_getLangOpts(D);
end;

function TDeclW.getAccess: AccessSpecifier;
begin
  Result := clangExt_Decl_getAccess(D);
end;

function TDeclW.getAccessUnsafe: AccessSpecifier;
begin
  Result := clangExt_Decl_getAccessUnsafe(D);
end;

function TDeclW.hasAttrs: Boolean;
begin
  Result := clangExt_Decl_hasAttrs(D);
end;

function TDeclW.getAttr(i: Cardinal): Attr;
begin
  Result := clangExt_Decl_getAttr(D, i);
end;

function TDeclW.getAttrCount: Cardinal;
begin
  Result := clangExt_Decl_getAttrCount(D);
end;

function TDeclW.getMaxAlignment: Cardinal;
begin
  Result := clangExt_Decl_getMaxAlignment(D);
end;

function TDeclW.isInvalidDecl: Boolean;
begin
  Result := clangExt_Decl_isInvalidDecl(D);
end;

function TDeclW.isImplicit: Boolean;
begin
  Result := clangExt_Decl_isImplicit(D);
end;

function TDeclW.isUsed(CheckUsedAttr: Boolean): Boolean;
begin
  Result := clangExt_Decl_isUsed(D, CheckUsedAttr);
end;

function TDeclW.isReferenced: Boolean;
begin
  Result := clangExt_Decl_isReferenced(D);
end;

function TDeclW.isThisDeclarationReferenced: Boolean;
begin
  Result := clangExt_Decl_isThisDeclarationReferenced(D);
end;

function TDeclW.isTopLevelDeclInObjCContainer: Boolean;
begin
  Result := clangExt_Decl_isTopLevelDeclInObjCContainer(D);
end;

function TDeclW.getExternalSourceSymbolAttr: ExternalSourceSymbolAttr;
begin
  Result := clangExt_Decl_getExternalSourceSymbolAttr(D);
end;

function TDeclW.isModulePrivate: Boolean;
begin
  Result := clangExt_Decl_isModulePrivate(D);
end;

function TDeclW.isInExportDeclContext: Boolean;
begin
  Result := clangExt_Decl_isInExportDeclContext(D);
end;

function TDeclW.hasDefiningAttr: Boolean;
begin
  Result := clangExt_Decl_hasDefiningAttr(D);
end;

function TDeclW.getDefiningAttr: Attr;
begin
  Result := clangExt_Decl_getDefiningAttr(D);
end;

function TDeclW.isWeakImported: Attr;
begin
  Result := clangExt_Decl_isWeakImported(D);
end;

function TDeclW.isFromASTFile: Boolean;
begin
  Result := clangExt_Decl_isFromASTFile(D);
end;

function TDeclW.getGlobalID: Cardinal;
begin
  Result := clangExt_Decl_getGlobalID(D);
end;

function TDeclW.getOwningModuleID: Cardinal;
begin
  Result := clangExt_Decl_getOwningModuleID(D);
end;

function TDeclW.getImportedOwningModule: Module;
begin
  Result := clangExt_Decl_getImportedOwningModule(D);
end;

function TDeclW.getLocalOwningModule: Module;
begin
  Result := clangExt_Decl_getLocalOwningModule(D);
end;

function TDeclW.hasOwningModule: Boolean;
begin
  Result := clangExt_Decl_hasOwningModule(D);
end;

function TDeclW.getOwningModule: Module;
begin
  Result := clangExt_Decl_getOwningModule(D);
end;

function TDeclW.getOwningModuleForLinkage(IgnoreLinkage: Boolean): Module;
begin
  Result := clangExt_Decl_getOwningModuleForLinkage(D, IgnoreLinkage);
end;

function TDeclW.isUnconditionallyVisible: Boolean;
begin
  Result := clangExt_Decl_isUnconditionallyVisible(D);
end;

function TDeclW.getModuleOwnershipKind: CX_Decl_ModuleOwnershipKind;
begin
  Result := clangExt_Decl_getModuleOwnershipKind(D);
end;

function TDeclW.getIdentifierNamespace: Cardinal;
begin
  Result := clangExt_Decl_getIdentifierNamespace(D);
end;

function TDeclW.isInIdentifierNamespace(NS: Cardinal): Boolean;
begin
  Result := clangExt_Decl_isInIdentifierNamespace(D, NS);
end;

class function TDeclW.getIdentifierNamespaceForKind(DK: CX_DeclKind): Cardinal;
begin
  Result := clangExt_Decl_getIdentifierNamespaceForKind(DK);
end;
       
function TDeclW.hasTagIdentifierNamespace: Boolean;
begin
  Result := clangExt_Decl_hasTagIdentifierNamespace(D);
end;

class function TDeclW.isTagIdentifierNamespace(NS: Cardinal): Boolean;
begin
  Result := clangExt_Decl_isTagIdentifierNamespace(NS);
end;

function TDeclW.getLexicalDeclContext: DeclContext;
begin
  Result := clangExt_Decl_getLexicalDeclContext(D);
end;

function TDeclW.isOutOfLine: Boolean;
begin
  Result := clangExt_Decl_isOutOfLine(D);
end;

function TDeclW.isTemplated: Boolean;
begin
  Result := clangExt_Decl_isTemplated(D);
end;

function TDeclW.getTemplateDepth: Cardinal;
begin
  Result := clangExt_Decl_getTemplateDepth(D);
end;

function TDeclW.isDefinedOutsideFunctionOrMethod: Boolean;
begin
  Result := clangExt_Decl_isDefinedOutsideFunctionOrMethod(D);
end;

function TDeclW.isInLocalScopeForInstantiation: Boolean;
begin
  Result := clangExt_Decl_isInLocalScopeForInstantiation(D);
end;

function TDeclW.getParentFunctionOrMethod: DeclContext;
begin
  Result := clangExt_Decl_getParentFunctionOrMethod(D);
end;

function TDeclW.getCanonicalDecl: TDeclW;
begin
  clangExt_Decl_getCanonicalDecl(D).Wrap(Result);
end;

function TDeclW.isCanonicalDecl: Boolean;
begin
  Result := clangExt_Decl_isCanonicalDecl(D);
end;

function TDeclW.getNumRedecls: Cardinal;
begin
  Result := clangExt_Decl_getNumRedecls(Self.D);
end;

function TDeclW.getRedecls(i: Cardinal): TDeclW;
begin
  clangExt_Decl_getRedecls(Self.D, i).Wrap(Result);
end;

function TDeclW.getPreviousDecl: TDeclW;
begin
  clangExt_Decl_getPreviousDecl(D).Wrap(Result);
end;

function TDeclW.isFirstDecl: Boolean;
begin
  Result := clangExt_Decl_isFirstDecl(D);
end;

function TDeclW.getMostRecentDecl: TDeclW;
begin
  clangExt_Decl_getMostRecentDecl(D).Wrap(Result);
end;

function TDeclW.getBody: Stmt;
begin
  Result := clangExt_Decl_getBody(D);
end;

function TDeclW.hasBody: Boolean;
begin
  Result := clangExt_Decl_hasBody(D);
end;

function TDeclW.getBodyRBrace: CXSourceLocation;
begin
  Result := clangExt_Decl_getBodyRBrace(D);
end;

function TDeclW.isTemplateParameter: Boolean;
begin
  Result := clangExt_Decl_isTemplateParameter(D);
end;

function TDeclW.isTemplateParameterPack: Boolean;
begin
  Result := clangExt_Decl_isTemplateParameterPack(D);
end;

function TDeclW.isParameterPack: Boolean;
begin
  Result := clangExt_Decl_isParameterPack(D);
end;

function TDeclW.isTemplateDecl: Boolean;
begin
  Result := clangExt_Decl_isTemplateDecl(D);
end;

function TDeclW.isFunctionOrFunctionTemplate: Boolean;
begin
  Result := clangExt_Decl_isFunctionOrFunctionTemplate(D);
end;

function TDeclW.getDescribedTemplate: TemplateDecl;
begin
  Result := clangExt_Decl_getDescribedTemplate(D);
end;

function TDeclW.getDescribedTemplateParams: TemplateParameterList;
begin
  Result := clangExt_Decl_getDescribedTemplateParams(D);
end;

function TDeclW.getAsFunction: FunctionDecl;
begin
  Result := clangExt_Decl_getAsFunction(D);
end;

function TDeclW.isLocalExternDecl: Boolean;
begin
  Result := clangExt_Decl_isLocalExternDecl(D);
end;

function TDeclW.getFriendObjectKind: CX_Decl_FriendObjectKind;
begin
  Result := clangExt_Decl_getFriendObjectKind(D);
end;

function TDeclW.castToDeclContext: DeclContext;
begin
  Result := clangExt_Decl_castToDeclContext(D);
end;

function TDeclW.getID: Int64;
begin
  Result := clangExt_Decl_getID(D);
end;

function TDeclW.getFunctionType(BlocksToo: Boolean): FunctionType;
begin
  Result := clangExt_Decl_getFunctionType(D, BlocksToo);
end;

function TDeclW.declaresSameEntity(other: TDeclW): Boolean;
begin
  Result := clangExt_Decl_declaresSameEntity(D, other.D);
end;

procedure TDeclW.dumpToFile(const fileName: string; Deserialize: Boolean;
  OutputFormat: ASTDumpOutputFormat);
begin
  clangExt_Decl_dumpToFile(D, PChar(fileName), Deserialize, OutputFormat);
end;

function TDeclW.dumpToString(Deserialize: Boolean;
  OutputFormat: ASTDumpOutputFormat): string;
begin
  Result := clangExt_Decl_dumpToString(D, Deserialize, OutputFormat).ToString;
end;

{$endregion 'TDeclW'}

{$region 'TDeclContextW'}

class function TDeclContextW.Create(const aCtx: DeclContext): TDeclContextW;
begin
  Result := Default(TDeclContextW);
  Result.Ctx := aCtx;
end;

function TDeclContextW.getDeclKind: CX_DeclKind;
begin
  Result := clangExt_DeclContext_getDeclKind(Self.Ctx);
end;

function TDeclContextW.getDeclKindName: string;
begin
  Result := StrPas(clangExt_DeclContext_getDeclKindName(Self.Ctx));
end;

function TDeclContextW.getParent: TDeclContextW;
begin
  clangExt_DeclContext_getParent(Self.Ctx).Wrap(Result);
end;

function TDeclContextW.getLexicalParent: TDeclContextW;
begin
  clangExt_DeclContext_getLexicalParent(Self.Ctx).Wrap(Result);
end;

function TDeclContextW.getLookupParent: TDeclContextW;
begin
  clangExt_DeclContext_getLookupParent(Self.Ctx).Wrap(Result);
end;

function TDeclContextW.getParentASTContext: ASTContext;
begin
  Result := clangExt_DeclContext_getParentASTContext(Self.Ctx);
end;

function TDeclContextW.isClosure: Boolean;
begin
  Result := clangExt_DeclContext_isClosure(Self.Ctx);
end;

function TDeclContextW.getInnermostBlockDecl: BlockDecl;
begin
  Result := clangExt_DeclContext_getInnermostBlockDecl(Self.Ctx);
end;

function TDeclContextW.isObjCContainer: Boolean;
begin
  Result := clangExt_DeclContext_isObjCContainer(Self.Ctx);
end;

function TDeclContextW.isFunctionOrMethod: Boolean;
begin
  Result := clangExt_DeclContext_isFunctionOrMethod(Self.Ctx);
end;

function TDeclContextW.isLookupContext: Boolean;
begin
  Result := clangExt_DeclContext_isLookupContext(Self.Ctx);
end;

function TDeclContextW.isFileContext: Boolean;
begin
  Result := clangExt_DeclContext_isFileContext(Self.Ctx);
end;

function TDeclContextW.isTranslationUnit: Boolean;
begin
  Result := clangExt_DeclContext_isTranslationUnit(Self.Ctx);
end;

function TDeclContextW.isRecord: Boolean;
begin
  Result := clangExt_DeclContext_isRecord(Self.Ctx);
end;

function TDeclContextW.isNamespace: Boolean;
begin
  Result := clangExt_DeclContext_isNamespace(Self.Ctx);
end;

function TDeclContextW.isStdNamespace: Boolean;
begin
  Result := clangExt_DeclContext_isStdNamespace(Self.Ctx);
end;

function TDeclContextW.isInlineNamespace: Boolean;
begin
  Result := clangExt_DeclContext_isInlineNamespace(Self.Ctx);
end;

function TDeclContextW.isDependentContext: Boolean;
begin
  Result := clangExt_DeclContext_isDependentContext(Self.Ctx);
end;

function TDeclContextW.isTransparentContext: Boolean;
begin
  Result := clangExt_DeclContext_isTransparentContext(Self.Ctx);
end;

function TDeclContextW.isExternCContext: Boolean;
begin
  Result := clangExt_DeclContext_isExternCContext(Self.Ctx);
end;

function TDeclContextW.getExternCContext: LinkageSpecDecl;
begin
  Result := clangExt_DeclContext_getExternCContext(Self.Ctx);
end;

function TDeclContextW.isExternCXXContext: Boolean;
begin
  Result := clangExt_DeclContext_isExternCXXContext(Self.Ctx);
end;

function TDeclContextW.Equals(DC: TDeclContextW): Boolean;
begin
  Result := clangExt_DeclContext_Equals(Self.Ctx, DC.Ctx);
end;

function TDeclContextW.Encloses(DC: TDeclContextW): Boolean;
begin
  Result := clangExt_DeclContext_Encloses(Self.Ctx, DC.Ctx);
end;

function TDeclContextW.getNonClosureAncestor: Decl;
begin
  Result := clangExt_DeclContext_getNonClosureAncestor(Self.Ctx);
end;

function TDeclContextW.getNonTransparentContext: TDeclContextW;
begin
  clangExt_DeclContext_getNonTransparentContext(Self.Ctx).Wrap(Result);
end;

function TDeclContextW.getPrimaryContext: TDeclContextW;
begin
  clangExt_DeclContext_getPrimaryContext(Self.Ctx).Wrap(Result);
end;

function TDeclContextW.getRedeclContext: TDeclContextW;
begin
  clangExt_DeclContext_getRedeclContext(Self.Ctx).Wrap(Result);
end;

function TDeclContextW.getEnclosingNamespaceContext: TDeclContextW;
begin
  clangExt_DeclContext_getEnclosingNamespaceContext(Self.Ctx).Wrap(Result);
end;

function TDeclContextW.getOuterLexicalRecordContext: RecordDecl;
begin
  Result := clangExt_DeclContext_getOuterLexicalRecordContext(Self.Ctx);
end;

function TDeclContextW.InEnclosingNamespaceSetOf(NS: TDeclContextW): Boolean;
begin
  Result := clangExt_DeclContext_InEnclosingNamespaceSetOf(Self.Ctx, NS.Ctx);
end;

function TDeclContextW.getNumDecls: Cardinal;
begin
  Result := clangExt_DeclContext_getNumDecls(Self.Ctx);
end;

function TDeclContextW.getDecls(i: Cardinal): TDeclW;
begin
  clangExt_DeclContext_getDecls(Self.Ctx, i).Wrap(Result);
end;

function TDeclContextW.decls_empty: Boolean;
begin
  Result := clangExt_DeclContext_decls_empty(Self.Ctx);
end;

function TDeclContextW.containsDecl(decl_: TDeclW): Boolean;
begin
  Result := clangExt_DeclContext_containsDecl(Self.Ctx, decl_.D);
end;

class function TDeclContextW.classof(decl: TDeclW): Boolean;
begin
  if not Assigned(decl.D) then
    Exit(False);
  Result := clangExt_DeclContext_classof(decl.D);
end;
   
{$endregion 'TDeclContextW'}

end.

